
# Generate the spacecraft files needed for FoxTelem from the csv file that defines
# the Downlink Spec
# g0kla@arrl.net

import getopt
import argparse
import sys

#Fields numbers and other constants used in the program

MetaData=0
SecondMetaData=1
CodeName = 2
BitSize = 3
Type = 5
BitOffset=9
ByteOffset=10
WordOffset=11
LongwordOffset=12
Space4 = "    "
ByteType = "uint8_t"
Bit16Type = "uint16_t"
Bit32Type = "uint32_t"
BitfieldType = "unsigned int"


def getStructure(file, structName,outfileName,defined):
    #This processes a "structure" section of the csv file and returns
    #a C structure as a string.  It assumes that 'file' is pointing at the
    #first line after the 'structure' line in the CSV file.

    ifdef = True

    #Initialize the string variable 'structure' with the common part
    ifdefName = (outfileName.replace('.','_')).upper() + "_"+defined
    structure = "#ifndef "+ifdefName+"\n#define "+ifdefName+"\n"
    structure +="//Created by GenFlightStruct.py from file DownlinkSpecGolf-T.xlsx\n"
    structure +="// Do not edit this file.\n"
    structure +="#ifndef "+defined+"\n"
    structure +="#error Wrong Archtecture\n"
    structure +="#endif\n"
    structure += "typedef struct  __attribute__((__packed__)) _"+structName+" {\n"
    
    for line in file:
        fields = line.split(',')
        if ('END' in fields[MetaData]):
            #We are done.  Add the ending braces and typedef name to the definition
            #and then return with the entire thing.
            structure += "} "+structName+"; // Total Size="+str(fields[BitOffset])
            structure += " bits or "+fields[ByteOffset]+" bytes with "
            leftover = int(fields[BitOffset])%8
            structure += str(leftover)+" left over"
            structure += "\n#endif\n"
            return structure
        if('ifdef' in fields[MetaData]):
            if (defined in fields[MetaData]):
                ifdef = True;
                continue
            else:
                ifdef = False;
                continue

        if('endif' in fields[MetaData]):
            ifdef = True;
            continue
        
        if (ifdef and "//" not in fields[MetaData]):
            # It is not a comment.  Do one line of the body of the definition.
            # What we want to do is: if the field size is the exact size of
            # of a byte, word, etc, and if it is on an even boundary of that
            # size, then we want to use the C type for that size (an array if
            # it is larger than one of them).  The "evenxxx" booleans tell whether
            # the above condition is true.  In addition, if the CSV file specifies
            # one of our known types, use it and specify the size as an array if it
            # is not 1.  If the CSV file specifies an unknown type, use that and
            # assume it is the right length.

            #Set up some variables telling what we have to make the other stuff
            #easier to read

            bitLen = int(fields[BitSize]) #How many bits
            
            evenByte = ((int(fields[BitOffset]) %8) == 0) and (bitLen%8 == 0)
            numBytes = bitLen//8 #Use integer divide just to be sure we don't get a float
            
            even16 =   ((int(fields[BitOffset])%16) == 0) and (bitLen%16 == 0)
            num16 = bitLen//16
            
            even32 = ((int(fields[BitOffset])%32) == 0) and (bitLen%32 == 0)
            num32 = bitLen//32

            # Default is (currently) a null line.
            defaultTypeSpecified = len(fields[Type]) == 0

            byteTypeSpecified = ByteType in fields[Type]
            bit32TypeSpecified = Bit32Type in fields[Type]

            # The following if/elif statements are in priority order (of course).  If the
            # CSV file specifies a byte type or a bit32 type, we want to use those and
            # make them an array if we must.  (even32, for example, would not work with
            # bit size=64, but bit32TypeSpecified does).
            
            if(byteTypeSpecified and evenByte):
                #Here the CSV told us explicitly to use a byte type
                #Do that if we are on a byte boundary
                structure+=Space4+ByteType+" "+fields[CodeName]+"["+str(numBytes)+"]"
            elif(bit32TypeSpecified and even32):
                #Here the CSV told us explicitly to use a 32-bit type
                #Do that if we are on a 32-bit boundary
                structure+=Space4+Bit32Type+" "+fields[CodeName]+"["+str(num32)+"]"
            elif(even32):
                #Here we are on an even 32-bit boundary with an even 32-bit field
                #By default, use Bit32Type (e.g. uint32_2).  Otherwise assume what
                #the CSV file told us is exactly the right length
                if(defaultTypeSpecified):
                    structure+=Space4+Bit32Type+" "+fields[CodeName]
                    if(num32 > 1):
                        structure+="["+str(num32)+"]"
                else:
                    structure+="    "+fields[Type]+" "+fields[CodeName]
            elif(even16):
                #Like even32 but with 16-bit boundaries
                if(defaultTypeSpecified):
                    structure+=Space4+Bit16Type+" "+fields[CodeName]
                    if(num16 > 1):
                        structure+="["+str(num16)+"]"
                else:
                    structure+="    "+fields[Type]+" "+fields[CodeName]
            elif(evenByte):
                #Like even32 but with byte boundaries
                if(defaultTypeSpecified):
                    structure+=Space4+ByteType+" "+fields[CodeName]
                    if(numBytes > 1):
                        structure+="["+str(numBytes)+"]"
                else:
                    structure+="    "+fields[Type]+" "+fields[CodeName]
            else:
                # Here either we are not on an even boundary or do not have an even length
                # The bool 'defaultTypeSpecified' can include a blank space, so if it is default, we
                # explicitly put in the DefaultType string.
                if(defaultTypeSpecified):
                    structure += Space4+BitfieldType
                else:
                    structure += "    "+fields[Type] #type
                structure += " "+fields[CodeName]    #field name
                structure += ":"+str(bitLen)

            structure +=';       //Offset='+fields[BitOffset]+'\n'
#----------------------------------End of function
#
# Start of main program
#
# Usage:
#    python FoxStruct.py name.csv [anything]
#
# name.csv is the file containing the csv file output from the Fox downlink spec
# anything is an optional string.  If it is blank, the structure is written to
# stdout. For anything else, the structures are written to the file specified
# in the csv file
#
ap = argparse.ArgumentParser(description='Turn a CSV file into C structures for Fox and Golf Satellites')
ap.add_argument("filename",help="Input CSV file")
ap.add_argument("-d","--define",required=False,metavar='xxx',default="",help="Use with #ifdef xxx")
ap.add_argument("-o","--output",required=False,action="store_true",help="If specified, output structs to file in the csv")

args = ap.parse_args()
fileName = args.filename

ifDefString = args.define

print("Define name specified is " + ifDefString)
writeOutputFile = args.output

with open(fileName) as infile:
    for line in infile:
        printit=False
        fields = line.split(',')
        # make sure this is not a comment nor a blank row and there is a filename
        if("//" not in fields[0]):
            if("Version:" in fields[0]):
                versionNum = (fields[0].split(':'))[1].strip()
                majorVersion = versionNum.split('.')[0].strip()
                minorVersion = versionNum.split('.')[1].strip()
                outFileName = 'downlinkVersion.h'
                typeStructure = "#ifndef DownlinkVersionMajor\n"
                typeStructure +="#define DownlinkVersionMajor "+majorVersion+"\n"
                typeStructure +="#define DownlinkVersionMinor "+minorVersion+"\n"
                typeStructure += "#endif\n"
                printit=True
            elif ((len(fields[1]) != 0) and ("Structure:" in fields[0])):
                structName = fields[0].split(':')[1].strip()
                outFileName = fields[1].split(':')[1].strip(' "')
                typeStructure = getStructure(infile,structName,outFileName,ifDefString)
                printit=True
            if(printit):
                if(writeOutputFile):
                    print("Writing "+outFileName)
                    outfile = open(outFileName,"w")
                    outfile.write(typeStructure)
                    outfile.close()
                else:
                    print(typeStructure)

